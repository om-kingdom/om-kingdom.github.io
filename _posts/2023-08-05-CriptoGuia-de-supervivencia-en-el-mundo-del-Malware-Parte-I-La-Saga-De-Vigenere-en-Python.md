---
layout: post
title: "Cripto-Guía de Supervivencia en el Mundo del Malware Parte I: La $aga de Vigenèr en Python"
date: 2023-08-05 21:37:56 +0100
categories: "Criptografia"
---

# Cripto-Guía de supervivenvia en el Mundo del Malware Parte I: La $aga de Vigenere en Python

Cripto-Guía de supervivencia en el Mundo del Malware es una nueva serie de posts para rx-malwarezone en la que exploraremos los diversos tipos de cifrado, describiéndolos a profundidad y haciendo implementaciones de los mismos en diversos lenguajes de programación.

# Una breve historia de Vigenère
Hoy es el turno del cifrado Vigenère, un método clásico de cifrado que se utiliza para ocultar el contenido de un mensaje mediante la sustitución de letras. Fue inventado por el criptógrafo francés Blaise de Vigenère en el siglo XVI. El cifrado Vigenère es una versión mas avanzada y segura del famoso cifrado César, que es un simple desplazamiento de letras.

El cifrado Vigenère se basa en el uso de una clave, que es una palabra o una frase corta. Esta clave se utiliza para desplazar cada letra del mensaje original por un valor correspondiente en el alfabeto. A diferencia del cifrado César, en el cifrado Vigenère, el desplazamiento cambia apra cada letra del mensaje según la posición de esa letra en la clave.

# Funcionamiento - Cifrado
- Se elige una clave, por ejemplo "SECRETO".
- Se repite la clave tantas veces como sea necesario para cubrir la longitud del mensaje. Si el mensaje es "HOLA MUNDO", y la clave es "SECRETO", entonces la clave repetida sería: "SECR ETOSE"
- Se asocia cada letra del mensaje con su correspondiente letra en la clave.
- Se desplaza la letra del mensaje original según su posición en el alfabeto. Por ejemplo si la letra del mensaje es "H" (posición 7 en el alfabeto) y la letra de la clave es "S" (posición 18 en el alfabeto), el resultado sería la posición 25 (7 + 18 = 25).
- En este punto del procedimiento se aplica la operación de modulo (MOD) entre la posición obtenida y la longitud del alfabeto utilizado para asegurar que el resultado se mantenga dentro de los limites del conjunto de valores permitidos. Por lo tanto la posición final obtenida tras la operación de modulo es 25. __Sí, es redundante aplicar la operación MOD pues seguimos teniendo 25 como resultado, pero no siempre la suma de las posiciones del mensaje y la clave se mantendrá dentro de la longitud del alfabeto__.
- Se repite el proceso para cada letra del mensaje
Simplificando toda la palabrería técnica que podría ir en este apartado, podemos decir que la operación de cifrado del método Vigenère puede ser representada en términos matemáticos con la siguiente expresión:
_E(Xi) = (Xi + Ki) mod L_

Donde...
- _E(Xi)_ representa la letra cifrada, o el valor numérico resultante después de aplicar el cifrado Vigenère a la letra original _Xi_.
- _Xi_ es el valor numérico de la letra original.
- _Ki_ es el valor numérico de la letra correspondiente en la clave a la posición _i_.
- _L_ es la longitud del alfabeto, generalmente 26 para el alfabeto inglés (A-Z).
Siguiendo el ejemplo anterior tenemos:
_E(7) = (7 + 18) mod 26 = 25 mod 26 = 25_
El valor numérico es 25 correspondiente a la letra "Y" en el alfabeto inglés. Por lo tanto, la letra "H" será cifrada como "Y" en este caso.

# Funcionamiento - Descifrado
Para descifrar solamente se realiza la operación inversa:

Cuando (Ci - Ki) >= 0
_D(Ci) = (Ci - Ki) mod L_

Cuando (Ci - Ki) < 0
_D(Ci) = (Ci - Ki + L) mod L_

Donde...
- _D(Ci)_ representa la letra descifrada, o el valor numérico resultante después de aplicar el proceso de descifrado.
- _Ci_ es el carácter en la posición _i_ del texto cifrado.
- _Ki_ es el carácter de la clave correspondiente a _Ci_.
- _L_ es el tamaño del alfabeto.

__Es importante mencionar que a una misma letra en el texto plano (sin cifrar) le pueden corresponder diferentes letras en el texto cifrado__.

# Creación de código
El código realizado en este post será en python.
Con todo lo mencionado anteriormente tenemos las herramientas necesarias para hacer un programa de cifrado y descifrado con el método Vigenère en Python.

```python
───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────
       │ File: vigenere.py
───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ # Lista que contiene todas las letras del alfabeto, incluyendo la Ñ
   2   │ alfabeto = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'Ñ', 'O', 'P', 'Q', '
       │ R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
   3   │ 
   4   │ # Función de menú
   5   │ def menu():
   6   │     seleccion = -1
   7   │     while (seleccion != 0):
   8   │         print("\n- 1. Cifrar. \n- 2. Descifrar\n- 0. Salir")
   9   │         seleccion = input("\nIntroduce tu seleccion: ")
  10   │         if(int(seleccion) == 1):
  11   │             # Llamar a la función para cifrar el mensaje
  12   │             cifrar()
  13   │         elif(int(seleccion) == 2):
  14   │             # Llamar a la funcion para descifrar un criptograma
  15   │             descifrar()
  16   │         elif(int(seleccion) == 0):
  17   │             print("\nrx - malwarezone")
  18   │             return
  19   │         else:
  20   │             print("\nIntroduce una opcion valida.")
  21   │ # Función para descifrar un mensaje utilizando el cifrado Vigenère
  22   │ def descifrar():
  23   │     criptograma = input("\nPor favor introduce el criptograma:\n")
  24   │ 
  25   │     #Verificar si el mensaje está vacío
  26   │     if not criptograma:
  27   │         print("\nCriptograma vacio.\n")
  28   │         return
  29   │     
  30   │     # Solicitar al usuario que ingrese la clave
  31   │     clave = input("\nPor favor, ingresa la clave:\n")
  32   │ 
  33   │     # Inicializar variable para almacenar la clave repetida hasta cubrir el criptograma
  34   │     criptogramaCubierto = ''
  35   │ 
  36   │     # Contadores para rastrear la posición actual en el criptograma y en la clave
  37   │     contadorCriptograma = 0
  38   │     contadorClave = 0
  39   │ 
  40   │     # Repetir hasta que el mensaje cubierto tenga la misma longitud que el criptograma
  41   │     while(len(criptogramaCubierto) != len(criptograma)):
  42   │         if(criptograma[contadorCriptograma] == " " or criptograma[contadorCriptograma] == ',' or cripto
       │ grama[contadorCriptograma] == '.'):
  43   │             # Si el carácter actual es un espacio o puntuacion
  44   │             criptogramaCubierto = criptogramaCubierto + criptograma[contadorCriptograma]
  45   │             contadorCriptograma = contadorCriptograma + 1
  46   │         else:
  47   │             # Calcular la posición del carácter de la clave en el alfabeto
  48   │             caracterClave = contadorClave % len(clave)
  49   │             criptogramaCubierto = criptogramaCubierto + clave[caracterClave]
  50   │             contadorCriptograma = contadorCriptograma + 1
  51   │             contadorClave = contadorClave +1
  52   │ 
  53   │     ### Aquí comienza el descifrado del criptograma
  54   │     # Variables temporales para almacenar letras y posiciones en el alfabeto
  55   │     letraCriptograma = ''
  56   │     posicionAlfabeticaLetraCriptograma = -1
  57   │     letraClave = ''
  58   │     posicionAlfabeticaLetraClave = ''
  59   │     posicionAlfabeticaDescifrado = -1
  60   │ 
  61   │     # Variable para almacenar el criptograma descifrado
  62   │     descifrado = ''
  63   │ 
  64   │     # Recorrer cada posicion en el criptograma
  65   │     for posicionCriptograma in range(len(criptograma)):
  66   │         # Obtener la letra actual del criptograma y la letra de la clave
  67   │         letraCriptograma = criptograma[posicionCriptograma]
  68   │         letraClave = criptogramaCubierto[posicionCriptograma]
  69   │ 
  70   │         # Si la letra del criptograma no es un espacio o puntuacion
  71   │         if(letraCriptograma != ' ' and letraCriptograma != ',' and letraCriptograma != '.'):
  72   │             # Obtener las posiciones en el alfabeto de las letras del criptograma y la clave
  73   │             posicionAlfabeticaLetraCriptograma = alfabeto.index(letraCriptograma)
  74   │             posicionAlfabeticaLetraClave = alfabeto.index(letraClave)
  75   │ 
  76   │             posicionAlfabeticaDescifrado = (posicionAlfabeticaLetraCriptograma - posicionAlfabeticaLetr
       │ aClave)
  77   │             if(posicionAlfabeticaDescifrado >= 0):
  78   │                 """
  79   │                 Calcular la nueva posicion en el alfabeto para el caracter descifrado
  80   │                 Cuando (Ci - Ki) >= 0
  81   │                 D(Ci) = (Ci - Ki) mod L
  82   │                 """
  83   │                 posicionAlfabeticaDescifrado = posicionAlfabeticaDescifrado % len(alfabeto)
  84   │             elif(posicionAlfabeticaDescifrado < 0):
  85   │                 """
  86   │                 Calcular la nueva posicion en el alfabeto para el caracter descifrado
  87   │                 Cuando (Ci - Ki) < 0
  88   │                 D(Ci) = (Ci - Ki + L) mod L
  89   │                 """
  90   │                 posicionAlfabeticaDescifrado = (posicionAlfabeticaDescifrado + len(alfabeto)) % len(alf
       │ abeto)  
  91   │             descifrado = descifrado + alfabeto[posicionAlfabeticaDescifrado]
  92   │         else: 
  93   │             descifrado = descifrado + letraCriptograma
  94   │ 
  95   │     # Mostrar el descrifrado resultante
  96   │     print("\n"+descifrado)
  97   │ 
  98   │ # Función para cifrar un mensaje utilizando el cifrado Vigenère
  99   │ def cifrar():
 100   │     # Solicitar al usuario que ingrese el mensaje en texto plano
 101   │     mensaje = input("\nPor favor, ingresa el texto plano:\n")
 102   │ 
 103   │     # Verificar si el mensaje está vacío
 104   │     if not mensaje:
 105   │         print("\nMensaje vacío.\n")
 106   │         return 
 107   │ 
 108   │     # Solicitar al usuario que ingrese la clave
 109   │     clave = input("\nPor favor, ingresa la clave:\n")
 110   │ 
 111   │     # Inicializar variable para almacenar la clave repetida hasta cubrir el mensaje
 112   │     mensajeCubierto = ''
 113   │ 
 114   │     # Contadores para rastrear la posición actual en el mensaje y en la clave
 115   │     contadorMensaje = 0
 116   │     contadorClave = 0
 117   │ 
 118   │     # Repetir hasta que el mensaje cubierto tenga la misma longitud que el mensaje original
 119   │     while(len(mensajeCubierto) != len(mensaje)):
 120   │         if(mensaje[contadorMensaje] == " " or mensaje[contadorMensaje] == "," or mensaje[contadorMensaj
       │ e] == "."):
 121   │             # Si el carácter actual es un espacio o puntuacion, simplemente agregar un espacio al mensaje cubierto
 122   │             mensajeCubierto = mensajeCubierto + mensaje[contadorMensaje]
 123   │             contadorMensaje = contadorMensaje + 1
 124   │         else:
 125   │             # Calcular la posición del carácter de la clave en el alfabeto
 126   │             caracterClave = contadorClave % len(clave)
 127   │             mensajeCubierto = mensajeCubierto + clave[caracterClave]
 128   │             contadorMensaje = contadorMensaje + 1
 129   │             contadorClave = contadorClave + 1
 130   │ 
 131   │     ### Aquí comienza la generación del criptograma (mensaje cifrado) ###
 132   │ 
 133   │     # Variables temporales para almacenar letras y posiciones en el alfabeto
 134   │     letraMensaje = ''
 135   │     posicionAlfabeticaLetraMensaje = -1
 136   │     letraClave = ''
 137   │     posicionAlfabeticaLetraClave = -1
 138   │     posicionAlfabeticaCriptograma = -1
 139   │ 
 140   │     # Variable para almacenar el criptograma resultante
 141   │     criptograma = ''
 142   │ 
 143   │     # Recorrer cada posición en el mensaje
 144   │     for posicionMensaje in range(len(mensaje)):
 145   │         # Obtener la letra actual del mensaje y la letra de la clave
 146   │         letraMensaje = mensaje[posicionMensaje]
 147   │         letraClave = mensajeCubierto[posicionMensaje]
 148   │ 
 149   │         # Si la letra del mensaje no es un espacio o puntuacion
 150   │         if(letraMensaje != ' ' and letraMensaje != ',' and letraMensaje != '.'):
 151   │             # Obtener las posiciones en el alfabeto de las letras del mensaje y la clave
 152   │             posicionAlfabeticaLetraMensaje = alfabeto.index(letraMensaje)
 153   │             posicionAlfabeticaLetraClave = alfabeto.index(letraClave)
 154   │ 
 155   │             # Calcular la nueva posición en el alfabeto para el carácter cifrado
 156   │             posicionAlfabeticaCriptograma = (posicionAlfabeticaLetraMensaje + posicionAlfabeticaLetraCl
       │ ave) % len(alfabeto)
 157   │ 
 158   │             # Agregar la letra cifrada al criptograma
 159   │             criptograma = criptograma + alfabeto[posicionAlfabeticaCriptograma]
 160   │         else:
 161   │             # Si el carácter es un espacio, agregar un espacio al criptograma
 162   │             criptograma = criptograma + letraMensaje
 163   │     
 164   │     # Mostrar el criptograma resultante
 165   │     print("\n"+criptograma)
 166   │ 
 167   │ # Llamar al menu
 168   │ menu()
───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────

```

# Pruebas
Para realizar las pruebas tomaré un minúsculo pedazo de todo el enorme libro que es Las Mil y Una Noches.
## Cifrado

```bash
- 1. Cifrar. 
- 2. Descifrar
- 0. Salir

Introduce tu seleccion: 1

Por favor, ingresa el texto plano:
GOBERNARON, PERO SE EXCEDIERON EN SUS PODERES, EN BREVE LOS PODERES CESARAN.
PARECERA COMO SI NUNCA HUBIERAN EXISTIDO. 
SI HUBIESEN OBRADO CON EQUIDAD, CON EQUIDAD HUBIESEN SIDO TRATADOS, PERO FUERON INJUSTOS, Y EL DESTINO HA SIDO A SU VEZ INJUSTO, LOS HA AFLIGIDO CON CALAMIDADES Y PRUEBAS.
LA VOZ DEL TIEMPO RECITA ESTO ES A CAMBIO DE AQUELLO, Y NO HAY MODO DE DISCUTIR CON EL DESTINO    

Por favor, ingresa la clave:
MILYUNANOCHES

RWMCMZAEDO, WIKA AO CROEPWGYSF PU DSN COPSTLW, WY JCCPQ LBH RVHWDMD AYFAEOO.
WEKPKOPU OOYD UO QNYKL FOÑIQGCT IPTAEGXB.
SU VWIMWEMX NVEAPD EVQ WCCSBUP, CBB GXYAOIÑ FOÑIQHGT WAOW EPUGAPDU, WIKA NFCMBN UBLBWMAA, J CF PEFIKTS ZM ASBJ N SH KGG MFUCDRJ, XOF VC HJDTÑSBJ OOZ QCREETLLBYF Y CGWLFSE.
SL TJM DQZ VOIEBW CCWUTN SUAS WE I NYGÑIB RG HUNPSVN, S ZO TOA SSVA LO BCFCHIKY GHY MV BYFTUBQ
```

## Descifrado

```bash
- 1. Cifrar. 
- 2. Descifrar
- 0. Salir

Introduce tu seleccion: 2

Por favor introduce el criptograma:
RWMCMZAEDO, WIKA AO CROEPWGYSF PU DSN COPSTLW, WY JCCPQ LBH RVHWDMD AYFAEOO. WEKPKOPU OOYD UO QNYKL FOÑIQGCT IPTAEGXB.
SU VWIMWEMX NVEAPD EVQ WCCSBUP, CBB GXYAOIÑ FOÑIQHGT WAOW EPUGAPDU, WIKA NFCMBN UBLBWMAA, J CF PEFIKTS ZM ASBJ N SH KGG MFUCDRJ, XOF VC HJDTÑSBJ OOZ QCREETLLBYF Y CGWLFSE. 
SL TJM DQZ VOIEBW CCWUTN SUAS WE I NYGÑIB RG HUNPSVN, S ZO TOA SSVA LO BCFCHIKY GHY MV BYFTUBQ

Por favor, ingresa la clave:
MILYUNANOCHES

GOBERNARON, PERO SE EXCEDIERON EN SUS PODERES, EN BREVE LOS PODERES CESARAN.
PARECERA COMO SI NUNCA HUBIERAN EXISTIDO.
SI HUBIESEN OBRADO CON EQUIDAD, CON EQUIDAD HUBIESEN SIDO TRATADOS, PERO FUERON INJUSTOS, Y EL DESTINO HA SIDO A SU VEZ INJUSTO, LOS HA AFLIGIDO CON CALAMIDADES Y PRUEBAS.
LA VOZ DEL TIEMPO RECITA ESTO ES A CAMBIO DE AQUELLO, Y NO HAY MODO DE DISCUTIR CON EL DESTINO
```
# Notas adicionales
El código resulto en un total de 168 lineas de largo, traté de hacer robusto el código pero aún hay mucho que se puede mejorar.
# Referencias
https://es.wikipedia.org/wiki/Cifrado_de_Vigen%C3%A8re

```
i been' ballin' out, boy it ain't nothin' major
```
